#!/usr/bin/env python3
"""
Sandbox Test Runner Script
===========================

This script is executed inside the sandbox container to run the test suite
and output results as JSON. It supports two modes:
- --pytest: Run all tests with a JSON report
- --code: Execute arbitrary Python code (for future extensions)
"""

import argparse
import json
import subprocess
import os
import sys
import traceback
from pathlib import Path


def run_pytest():
    """Run pytest and output JSON results."""
    # Change to workspace directory if mounted
    if os.path.exists("/workspace"):
        os.chdir("/workspace")
    
    # Set up report file path
    report_file = "/workspace/.nova/pytest_report.json"
    
    # Ensure .nova directory exists
    Path("/workspace/.nova").mkdir(exist_ok=True)
    
    # Build pytest command
    cmd = [
        "pytest",
        "--json-report",
        f"--json-report-file={report_file}",
        "--json-report-indent=2",
        "-q",  # Quiet mode
        "--tb=short",  # Short traceback format
        "--timeout=60",  # 60 second timeout per test
        "--no-header",  # Don't show pytest header
        "-v"  # Verbose (show test names)
    ]
    
    # Run pytest and capture output
    proc = subprocess.run(
        cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True
    )
    
    exit_code = proc.returncode
    data = {}
    
    # Try to load the JSON report generated by the plugin
    try:
        with open(report_file, "r") as f:
            data = json.load(f)
    except FileNotFoundError:
        data = {
            "error": "JSON report file not found",
            "stdout": proc.stdout.strip(),
            "stderr": proc.stderr.strip()
        }
    except json.JSONDecodeError as e:
        data = {
            "error": f"Failed to parse JSON report: {e}",
            "stdout": proc.stdout.strip(),
            "stderr": proc.stderr.strip()
        }
    except Exception as e:
        data = {
            "error": f"Unexpected error reading report: {e}",
            "stdout": proc.stdout.strip(),
            "stderr": proc.stderr.strip()
        }
    
    # Always include exit code
    data["exit_code"] = exit_code
    
    # If the JSON report is empty or missing key fields, include captured output
    if not data or ("tests" not in data and "summary" not in data):
        out_str = proc.stdout.strip()
        err_str = proc.stderr.strip()
        if out_str and "stdout" not in data:
            data["stdout"] = out_str
        if err_str and "stderr" not in data:
            data["stderr"] = err_str
    
    # Extract key information for easier processing
    if "summary" in data:
        summary = data["summary"]
        data["test_summary"] = {
            "total": summary.get("total", 0),
            "passed": summary.get("passed", 0),
            "failed": summary.get("failed", 0),
            "skipped": summary.get("skipped", 0),
            "errors": summary.get("error", 0)
        }
    
    # Extract failing test details
    if "tests" in data:
        failing_tests = []
        for test in data["tests"]:
            if test.get("outcome") in ["failed", "error"]:
                failing_tests.append({
                    "nodeid": test.get("nodeid"),
                    "outcome": test.get("outcome"),
                    "message": test.get("call", {}).get("longrepr", ""),
                    "file": test.get("nodeid", "").split("::")[0] if "::" in test.get("nodeid", "") else ""
                })
        if failing_tests:
            data["failing_tests"] = failing_tests
    
    # Print the result as a single line JSON string
    print(json.dumps(data))
    sys.stdout.flush()


def run_code(code_str: str):
    """Execute arbitrary code and capture any output."""
    try:
        # Create a safe execution environment
        import io
        buffer = io.StringIO()
        old_stdout = sys.stdout
        sys.stdout = buffer
        
        # Execute the provided code string
        exec_globals = {}
        exec(code_str, exec_globals)
        
        # Restore stdout
        sys.stdout = old_stdout
        output = buffer.getvalue()
        
        result = {"exit_code": 0}
        if output:
            result["stdout"] = output
            
    except Exception as e:
        # Capture the full traceback
        tb = traceback.format_exc()
        result = {
            "exit_code": 1,
            "error": str(e),
            "traceback": tb
        }
    
    # Print result of code execution as JSON
    print(json.dumps(result))
    sys.stdout.flush()


def main():
    """Main entry point for the sandbox runner."""
    parser = argparse.ArgumentParser(
        description="Sandbox test runner for Nova CI-Rescue"
    )
    parser.add_argument(
        "--pytest",
        action="store_true",
        help="Run pytest and output JSON results"
    )
    parser.add_argument(
        "--code",
        type=str,
        help="Execute given Python code string and output result"
    )
    
    args = parser.parse_args()
    
    if args.pytest:
        run_pytest()
    elif args.code is not None:
        run_code(args.code)
    else:
        parser.print_help()
        sys.exit(1)


if __name__ == "__main__":
    main()
