"""
PR Generator - Uses GPT-5 to create pull request descriptions and submit them via GitHub CLI.
"""

import subprocess
from pathlib import Path
from typing import Dict, List, Tuple, Optional
from nova.agent.llm_client import LLMClient


class PRGenerator:
    """Generates and creates pull requests using AI and GitHub CLI."""
    
    def __init__(self, repo_path: Path):
        self.repo_path = Path(repo_path)
        self.llm = LLMClient()
    
    def generate_pr_content(self, 
                          fixed_tests: List[Dict],
                          patches_applied: List[str],
                          changed_files: List[str],
                          execution_time: str) -> Tuple[str, str]:
        """
        Use GPT-5 to generate PR title and description based on what was fixed.
        
        Returns:
            Tuple of (title, description)
        """
        # Build context for GPT-5
        prompt = f"""Generate a professional GitHub pull request title and description for the following automated test fixes:

FIXED TESTS ({len(fixed_tests)} total):
"""
        for test in fixed_tests[:5]:  # Show first 5
            prompt += f"- {test.get('name', 'Unknown')} in {test.get('file', 'unknown file')}\n"
        
        if len(fixed_tests) > 5:
            prompt += f"... and {len(fixed_tests) - 5} more\n"
        
        prompt += f"\nFILES CHANGED:\n"
        for file in changed_files:
            prompt += f"- {file}\n"
        
        prompt += f"\nEXECUTION TIME: {execution_time}\n"
        prompt += f"NUMBER OF ITERATIONS: {len(patches_applied)}\n"
        
        # Add patch summaries if available
        if patches_applied:
            prompt += f"\nPATCH SUMMARY:\n"
            for i, patch in enumerate(patches_applied[:3], 1):
                lines = patch.split('\n')
                # Extract what was changed
                files_in_patch = [line[6:] for line in lines if line.startswith('--- a/')]
                if files_in_patch:
                    prompt += f"Iteration {i}: Fixed {', '.join(files_in_patch)}\n"
        
        prompt += """
Generate:
1. A concise PR title (max 72 chars) that summarizes what was fixed
2. A detailed PR description in markdown that includes:
   - Summary of what was broken and what was fixed
   - List of specific changes made
   - Test results (before/after)
   - Any relevant technical details
   - Footer with automation credits

Format your response as:
TITLE: <title here>
DESCRIPTION:
<description here>
"""
        
        try:
            response = self.llm.complete(
                system="You are a helpful AI that writes excellent pull request descriptions. Be specific about what was fixed and professional in tone.",
                user=prompt,
                temperature=1.0,  # GPT-5 only supports temperature=1
                max_tokens=2000
            )
            
            # Debug: log the response
            if not response:
                print("[yellow]Warning: Empty response from LLM[/yellow]")
            else:
                print(f"[dim]LLM response length: {len(response)} chars[/dim]")
            
            # Parse response
            lines = response.split('\n') if response else []
            title = ""
            description_lines = []
            in_description = False
            
            for line in lines:
                if line.startswith("TITLE:"):
                    title = line[6:].strip()
                elif line.strip() == "DESCRIPTION:":
                    in_description = True
                elif in_description:
                    description_lines.append(line)
            
            description = '\n'.join(description_lines).strip()
            
            # If we couldn't parse title/description, use the full response
            if not title and not description and response:
                # Try to extract a title from the first line
                first_line = response.split('\n')[0] if response else ""
                if len(first_line) <= 72:
                    title = first_line
                    description = '\n'.join(response.split('\n')[1:]).strip()
                else:
                    title = f"fix: Fix {len(fixed_tests)} failing test(s)"
                    description = response
            
            # Ensure we have at least a basic title and description
            if not title:
                title = f"fix: Fix {len(fixed_tests)} failing test(s)"
            
            if not description:
                description = "This PR fixes failing tests in the codebase."
            
            # Add automation footer if not present
            if "Nova CI-Rescue" not in description:
                description += "\n\n---\n*This PR was automatically generated by [Nova CI-Rescue](https://github.com/novasolve/ci-auto-rescue) 🤖*"
            
            return title, description
            
        except Exception as e:
            # Fallback to simple description
            print(f"Error generating PR with AI: {e}")
            title = f"fix: Fix {len(fixed_tests)} failing test(s)"
            description = f"""## Summary

This PR fixes {len(fixed_tests)} failing test(s) that were automatically identified and resolved.

## Changes Made

The following files were modified:
{chr(10).join(f'- `{f}`' for f in changed_files)}

## Test Results

- **Before**: {len(fixed_tests)} tests failing ❌
- **After**: All tests passing ✅

## Execution Details

- Time taken: {execution_time}
- Iterations needed: {len(patches_applied)}

---
*This PR was automatically generated by [Nova CI-Rescue](https://github.com/novasolve/ci-auto-rescue) 🤖*
"""
            return title, description
    
    def create_pr(self, 
                  branch_name: str,
                  title: str, 
                  description: str,
                  base_branch: str = "main",
                  draft: bool = False) -> Tuple[bool, str]:
        """
        Create a PR using GitHub CLI.
        
        Args:
            branch_name: The branch with fixes
            title: PR title
            description: PR description
            base_branch: Target branch (default: main)
            draft: Create as draft PR
            
        Returns:
            Tuple of (success, pr_url_or_error)
        """
        try:
            # First check if gh is installed
            check_gh = subprocess.run(
                ["which", "gh"],
                capture_output=True,
                text=True
            )
            
            if check_gh.returncode != 0:
                return False, "GitHub CLI (gh) not found. Install with: brew install gh"
            
            # Check if we have a git remote
            remote_check = subprocess.run(
                ["git", "remote", "-v"],
                capture_output=True,
                text=True,
                cwd=self.repo_path
            )
            
            if not remote_check.stdout.strip():
                return False, "No git remotes found. This appears to be a local repository without a GitHub remote."
            
            # Check if we're authenticated
            auth_check = subprocess.run(
                ["gh", "auth", "status"],
                capture_output=True,
                text=True,
                cwd=self.repo_path
            )
            
            if auth_check.returncode != 0:
                return False, "Not authenticated with GitHub. Run: gh auth login"
            
            # Create the PR
            cmd = [
                "gh", "pr", "create",
                "--base", base_branch,
                "--head", branch_name,
                "--title", title,
                "--body", description
            ]
            
            if draft:
                cmd.append("--draft")
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                cwd=self.repo_path
            )
            
            if result.returncode == 0:
                pr_url = result.stdout.strip()
                return True, pr_url
            else:
                error_msg = result.stderr or result.stdout
                return False, f"Failed to create PR: {error_msg}"
                
        except Exception as e:
            return False, f"Error creating PR: {str(e)}"
    
    def check_pr_exists(self, branch_name: str) -> bool:
        """Check if a PR already exists for this branch."""
        try:
            result = subprocess.run(
                ["gh", "pr", "list", "--head", branch_name, "--json", "number"],
                capture_output=True,
                text=True,
                cwd=self.repo_path
            )
            
            if result.returncode == 0 and result.stdout.strip() != "[]":
                return True
            return False
        except:
            return False
